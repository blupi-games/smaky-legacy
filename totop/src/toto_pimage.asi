	.SBTTL	TOTO_PIMAGE.ASI;--------\\; AFIMAGE >;========/; Affiche une image.; in	D4.W	numro de l'image (0..999);	D3.L	position (y;x);	D2.W	progression;	D1.L	incrment/dlai; out	D7.W	erreur; mod	D7.WAFIMAGE:	PUSHM.L	D4,A2,A4	LOAD.W	(A6)+OIMA,D4	; OIMA <-- numro de l'image	CALL	GETDIMAGE	; A2 <-- ^ODI*	CALL	GMATIMAGE	; A4/D4 <-- ^image/dimensions	JUMP',NE EXIT$	CALL	OBJDRAW		; dessine les objets	CALL	SHOWIMAGE	; affiche l'image	LOAD.L	A4,(A2)+ODIPC	CALL	CLUTIMAGE	; change la CLUT	TEST.L	(A2)+ODIPD	JUMP',EQ OK$	LOAD.L	A4,(A2)+ODIPD	CALL	FREEIMAGE	; libre l'image dcode	CLR.L	(A2)+ODIPDOK$:	CLR.W	D7		; D7 <-- okEXIT$:	POPM.L	D4,A2,A4	TEST.W	D7		; retour EQ/NE	RET;----------\\; GMATIMAGE >;==========/; Affiche une image.; in	D4.W	numro de l'image (0..999); out	A4.L	^image;	D4.L	dimensions;	D7.W	erreur; mod	D4.L, D7.W, A4.LGMATIMAGE:	PUSHM.L	D3,A2	CALL	GETDIMAGE	; A2 <-- ^ODI*	CALL	CACHEIMAGE	; cache l'image (si ncessaire)	JUMP',NE EXIT$	TEST.L	(A2)+ODIPD	JUMP',EQ FREE$	LOAD.L	A4,(A2)+ODIPD	CALL	FREEIMAGE	; libre l'image dcode	CLR.L	(A2)+ODIPDFREE$:	CLR.W	D3		; D3 <-- inverse si ncessaire	TEST.W	D4		; image 000 (l'image des pices) ?	JUMP',NE DECO$		; non => DECO$	LOAD.W	D3,#1		; D3 <-- n'inverse pas !DECO$:	CALL	DECOIMAGE	; A4 <-- ^image dcode	JUMP',NE EXIT$	LOAD.L	(A2)+ODIPD,A4	LOAD.L	(A2)+ODIDIM,D4EXIT$:	POPM.L	D3,A2	TEST.W	D7		; retour EQ/NE	RET;-----------\\; CACHEIMAGE >;===========/; Cache une image, si ncessaire.; in	D4.W	numro de l'image (0..999); out	D7.W	erreur; mod	D7.WCACHEIMAGE:	PUSHM.L	D3,D4,A2..A4	CALL	GETDIMAGE	; A2 <-- ^ODI*	TEST.L	(A2)+ODIPC	; image dj charge ?	JUMP',NE OK$		; oui => OK$	CALL	NAMEIMAGE	; A3 <-- ^nom	CALL	LOADIMAGE	JUMP',NE EXIT$	LOAD.L	(A2)+ODIPC,A4	CLR.L	(A2)+ODIPDOK$:	CLR.W	D7		; D7 <-- okEXIT$:	POPM.L	D3,D4,A2..A4	TEST.W	D7		; retour EQ/NE	RET;-------------\\; UNCACHEIMAGE >;=============/; Dcache une image, si ncessaire.; in	D4.W	numro de l'image (0..999); out	-; mod	D7.WUNCACHEIMAGE:	PUSHM.L	D3,D4,A2..A4	CALL	GETDIMAGE	; A2 <-- ^ODI*	TEST.L	(A2)+ODIPC	; image dj libre ?	JUMP',EQ EXIT$		; oui => EXIT$	TEST.L	(A2)+ODIPD	JUMP',EQ CODE$	LOAD.L	A4,(A2)+ODIPD	CALL	FREEIMAGE	; libre l'image dcodeCODE$:	LOAD.L	A4,(A2)+ODIPC	CALL	FREEIMAGE	; libre l'image code	CLR.L	(A2)+ODIPC	CLR.L	(A2)+ODIPDEXIT$:	POPM.L	D3,D4,A2..A4	RET;----------\\; GETDIMAGE >;----------/; Cherche le descripteur d'une image.; in	D4.W	numro de l'image (0..999); out	A2.L	^ODI*; mod	D7.W, A2.LGETDIMAGE:	PUSH.L	D4	LOAD.L	A2,#(A6)+ODI	MUL.WU	D4,#LDI	ADD.L	A2,D4		; A2 <-- ^ODI*	POP.L	D4	RET;----------\\; NAMEIMAGE >;==========/; Gnre le nom d'une image.; in	D4.W	numro de l'image (0..999); out	A3.L	^nom; mod	D7.W, A3.LNAMEIMAGE:	PUSHM.L	D2..D4,A4	LOAD.L	A4,#(A6)+OBUFIM	LOAD.L	A3,#R16"PREF$XFER1$:	LOAD.B	(A4+),(A3+)	; OBUFIM <-- prfixe	JUMP,NE XFER1$	DEC.L	A4	LOAD.W	D2,#2^BAFDALL	LOAD.W	D3,#3	AND.L	D4,#H'FFFF	LIB	?PUTDEC		; OBUFIM <-- numro	LOAD.L	A3,#R16"POSTC$	TEST.B	(A0)+ODFCMD	; cran couleur ?	JUMP',NE XFER2$		; oui => XFER2$	LOAD.L	A3,#R16"POSTN$XFER2$:	LOAD.B	(A4+),(A3+)	; OBUFIM <-- extension	JUMP,NE XFER2$;	DEC.L	A4	LOAD.L	A3,#(A6)+OBUFIM	; A3 <-- ^nom	POPM.L	D2..D4,A4	RETPREF$:	.ASCIZ	"(:,#:)TOTO_P"POSTN$:	.ASCIZ	".IMAGE"POSTC$:	.ASCIZ	".COLOR"	.EVEN;----------\\; LOADIMAGE >;==========/; Charge une image en mmoire.; in	A3.L	^nom de l'image; out	A4.L	^image code;	D7.W	erreur; mod	D7.W, A4.LLOADIMAGE:	PUSHM.L	D1,D3,D4,D6	LOAD.W	D3,#2^BOPRD!2^BOPSYS ; D3 <-- mode d'ouverture	FOS	?OPEN		; ouvre l'image	JUMP,NE EXIT$	LOAD.L	D4,#-1	LOAD.B	D3,D4	FOS	?SPOS		; D4 <-- longueur du fichier	PUSH.L	D4	CLR.L	D4	CLR.B	D3	FOS	?SPOS		; revient au dbut	POP.L	D4	LOAD.W	D1,#MTYPCP	CALL	GETMEM		; A4 <-- ^buffer pour le fichier image	JUMP',NE 82$	FOS	?RDBYTE		; lit tout le fichier image	JUMP',EQ 82$80$:	PUSH.W	D7	LOAD.W	D1,#MTYPCP	GESMEM	?GIVMEM		; rend la mmoire de l'image	POP.W	D782$:	PUSH.W	D7	FOS	?CLOSE		; ferme l'image	POP.W	D7EXIT$:	POPM.L	D1,D3,D4,D6	TEST.W	D7		; retour EQ/NE	RET;----------\\; DECOIMAGE >;==========/; Dcode une image noir/blanc ou couleur en mmoire.; in	A2.L	^dans ODI*;	D3.W	mode (1 => n'inverse pas); out	A4.L	^image dcode;	D4.L	dimensions (dy;dx);	D7.W	erreur; mod	D4.L, D7.W, A4.LDECOIMAGE:	PUSHM.L	D0..D3,A1..A3,A5	LOAD.L	A5,A2		; A5 <-- ^dans ODI*	LOAD.L	A2,(A5)+ODIPC	; A2 <-- ^image code (en-tte)	LOAD.W	D0,(A2)+OIMDLX	; D0 <-- largeur de l'image	LOAD.W	D1,(A2)+OIMDLY	; D1 <-- hauteur de l'image	COMP.B	(A2)+OIMBIP,#1	; image couleur ?	JUMP,NE COLOR$		; oui => COLOR$	LOAD.W	D4,D0	SR.W	D4,#3	MUL.WU	D4,D1		; D4 <-- largeur*hauteur/8	PUSH.L	D1	LOAD.W	D1,#MTYPCP	PUSH.L	(A5)+ODIPC	CLR.L	(A5)+ODIPC	CALL	GETMEM		; demande un buffer pour l'image dcode	POP.L	(A5)+ODIPC	POPM.L	D1	TEST.W	D7	JUMP,NE EXIT$	LOAD.L	A1,A4		; A1 <-- ^image	TEST.B	(A2)+OIMCOD	JUMP',EQ NBXFER$	LOAD.L	A4,#(A2)+LGHIMA	; A4 <-- ^image code (source)	LOAD.L	A3,A1		; A3 <-- ^buffer (destination)	PUSH.B	(A2)+OIMCOD	PUSH.L	(A2)+OIMNBB	GRA_	DECOIMA		; dcode l'image ...	POP.L	(A2)+OIMNBB	POP.B	(A2)+OIMCOD	TEST.W	D7	JUMP,NE FREE$	LOAD.L	A4,A1		; A4 <-- ^image	JUMP'	INV$NBXFER$:	LOAD.L	A4,#(A2)+LGHIMA	; A4 <-- ^image code (source)	LOAD.L	A3,A1		; A3 <-- ^buffer (destination)	PUSH.L	D4	SR.L	D4,#2+2	DEC.W	D4NBXFER2$:	LOAD.L	(A3+),(A4+)	LOAD.L	(A3+),(A4+)	LOAD.L	(A3+),(A4+)	LOAD.L	(A3+),(A4+)	DECJ.W,NMO D4,NBXFER2$	POP.L	D4	LOAD.L	A4,A1		; A4 <-- ^image;	JUMP'	INV$INV$:	COMP.W	D3,#1	JUMP,EQ OK$	TEST.B	(A6)+OINV	; fond de l'cran blanc ?	JUMP,T	OK$		; oui => OK$	SR.L	D4,#2+2	DEC.W	D4ILOOP$:	NOT.L	(A1+)		; inverse l'image	NOT.L	(A1+)	NOT.L	(A1+)	NOT.L	(A1+)	DECJ.W,NMO D4,ILOOP$	JUMP	OK$COLOR$:	CLR.W	D4	LOAD.B	D4,(A2)+OIMBIP	MUL.WU	D4,D0	SR.W	D4,#3	MUL.WU	D4,D1		; D4 <-- largeur*hauteur/8	PUSH.L	D1	LOAD.W	D1,#MTYPCP	PUSH.L	(A5)+ODIPC	CLR.L	(A5)+ODIPC	CALL	GETMEM		; demande un buffer pour l'image dcode	POP.L	(A5)+ODIPC	POPM.L	D1	TEST.W	D7	JUMP,NE EXIT$	LOAD.L	A1,A4		; A1 <-- ^image	TEST.B	(A2)+OIMCOD	JUMP',EQ CXFER$	LOAD.L	A4,#(A2)+LGHIMA	; A4 <-- ^CLUT	ADD.L	A4,(A2)+OIMLGC	; A4 <-- ^image code (source)	LOAD.L	A3,A1		; A3 <-- ^buffer (destination)	PUSH.B	(A2)+OIMCOD	PUSH.L	(A2)+OIMNBB	PUSH.W	(A2)+OIMDLX	PUSH.B	(A2)+OIMBIP	CLR.W	D4	LOAD.B	D4,(A2)+OIMBIP	MUL.WU	D4,(A2)+OIMDLX	LOAD.W	(A2)+OIMDLX,D4	LOAD.B	(A2)+OIMBIP,#1	GRA_	DECOIMA		; dcode l'image ...	POP.B	(A2)+OIMBIP	POP.W	(A2)+OIMDLX	POP.L	(A2)+OIMNBB	POP.B	(A2)+OIMCOD	TEST.W	D7	JUMP,NE FREE$	LOAD.L	A4,A1		; A4 <-- ^image	JUMP'	OK$CXFER$:	LOAD.L	A4,#(A2)+LGHIMA	; A4 <-- ^CLUT	ADD.L	A4,(A2)+OIMLGC	; A4 <-- ^image code (source)	LOAD.L	A3,A1		; A3 <-- ^buffer (destination)	SR.L	D4,#2+2	DEC.W	D4CXFER2$:	LOAD.L	(A3+),(A4+)	LOAD.L	(A3+),(A4+)	LOAD.L	(A3+),(A4+)	LOAD.L	(A3+),(A4+)	DECJ.W,NMO D4,CXFER2$	LOAD.L	A4,A1		; A4 <-- ^image;	JUMP'	OK$OK$:	LOAD.W	D4,D1	SWAP.W	D4	LOAD.W	D4,D0		; D4 <-- dimensions de l'image	JUMP'	EXIT$FREE$:	LOAD.L	A4,A1	CALL	FREEIMAGE	; rend la mmoire de l'imageEXIT$:	POPM.L	D0..D3,A1..A3,A5	TEST.W	D7		; retour EQ/NE	RET;----------\\; CLUTIMAGE >;==========/; Modifie la CLUT pour une image donne.; in	A4.L	^image code; out	-; mod	D7.WCLUTIMAGE:	PUSHM.L	D3,D6,A3	COMP.B	(A4)+OIMBIP,#1	; image couleur ?	JUMP',EQ EXIT$		; non => EXIT$	LOAD.L	A3,#(A4)+LGHIMA	; A3 <-- ^CLUT	LOAD.L	D3,#2^BTCTABLE	; D3 <-- mode	LOAD.L	D6,(A0)+ODFCPF	; D6 <-- canal pour TCOLOR	TCOL_	LOADCLUT	; change la CLUTEXIT$:	POPM.L	D3,D6,A3	RET;----------\\; FREEIMAGE >;==========/; Libre la mmoire occupe par une image dcode-; in	A4.L	^image; out	-; mod	-FREEIMAGE:	PUSHM.L	D1,D7	LOAD.W	D1,#MTYPCP	GESMEM	?GIVMEM		; rend la mmoire de l'image	POPM.L	D1,D7	RET;----------\\; SHOWIMAGE >;==========/; Affiche une image dans la (sous-)fentre.; in	A4.L	^image;	D3.L	position (y;x);	D4.L	dimensions (dy;dx);	D2.W	progression;	D1.L	incrment/dlai; out	-; mod	D7.WSHOWIMAGE:	PUSHM.L	D0..D6,A0,A3,A4	LOAD.W	D0,D2		; D0 <-- progression	LOAD.L	D2,D4		; D2 <-- dimensions	LOAD.L	D4,D3		; D4 <-- position destination	CLR.L	D3		; D3 <-- position source	LOAD.W	D5,D2	SR.W	D5,#3		; D5 <-- Iy source	LOAD.L	A3,A4		; A3 <-- ^image (source)	LOAD.L	A4,#0		; A4 <-- ^cran (destination)	TEST.B	(A6)+OFAN+3:#BFQUICK-0	JUMP',BS QUICK$	COMP.W	D0,#PROGQUICK	JUMP',EQ QUICK$	TEST.B	(A0)+ODFCMD	; cran couleur ?	JUMP',EQ PROG$		; non => PROG$	CLR.W	D7	LOAD.B	D7,(A0)+ODFCNP	MUL.WU	D5,D7PROG$:	LOAD.L	A0,(A6)+OCAFOND	FONDU_	PROGRESS	; moteur ...	JUMP'	EXIT$QUICK$:	LOAD.L	D1,D2	LOAD.W	D2,#LOADDOT	; D2 <-- mode	TEST.B	(A0)+ODFCMD	; cran couleur ?	JUMP',EQ RASTER$	; non => RASTER$	LOAD.W	D2,#LOADDOT!2^BSRCCOUL!2^BDSTCOULRASTER$:	CALL	DRRASTEREXIT$:	POPM.L	D0..D6,A0,A3,A4	RET	.END