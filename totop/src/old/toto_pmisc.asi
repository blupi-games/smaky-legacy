	.SBTTL	TOTO_PMISC.ASI; Gestion de la mmoire; ---------------------;--------\\; GETMEM  >;========/; Demande une tranche mmoire. Libre des sons ou des images; s'il ne reste pas assez de mmoire.; in	D4.L	lg demande;	D1.W	compte mmoire; out	A4.L	^tranche alloue;	D7.W	erreur; mod	D7.W, A4.LGETMEM:	PUSHM.L	D3..D5	LOAD.L	D3,D4	GESMEM	?ARGMEM		; D4/D5 <-- total/plus grand trou	JUMP',NE EXIT$	LOAD.L	D4,D3	ADD.L	D4,#RESMEM	COMP.L	D4,D5		; reste assez de mmoire libre ?	JUMP',LO GETMEM$	; oui => GETMEM$	CALL	FREEMEM		; libre le maximumGETMEM$:	LOAD.L	D4,D3	GESMEM	?GETMEM		; A4 <-- ^tranche mmoireEXIT$:	POPM.L	D3..D5	TEST.W	D7		; retour EQ/NE	RET;--------\\; FREEMEM >;--------/; Libre tout ce qui est possible.; in	-; out	-; mod	D7.WFREEMEM:	PUSHM.L	D4	LOAD.W	D4,#1		; D4 <--  partir de TOTO_P001.IMAGE (conserve TOTO_P000.IMAGE)ILOOP$:	CALL	UNCACHEIMAGE	; libre une image	INC.W	D4	COMP.W	D4,#MAXIMAGE	JUMP,LO ILOOP$	LOAD.W	D4,#H'10*1	; D4 <--  partir de TOTO_P001.AUDIO (conserve TOTO_P000.AUDIO)SLOOP$:	CALL	SNDUNCACHE	; libre un son	ADD.W	D4,#H'10*1	COMP.W	D4,#H'10*MAXSOUND	JUMP,LO SLOOP$	POPM.L	D4	RET; Tirage de nombres alatoires; ----------------------------;--------\\; COUPSAC >;========/; Coup de sac pour le gnrateur alatoire.; in	-; out	-; mod	D7.WCOUPSAC:	PUSHM.L	D3,D4	LIB	?RDCLOCK	; D3/D4 <-- date et heure	RR.L	D3,#3	RL.L	D4,#7		; savante cuisine	NOT.L	D3	XOR.L	D4,D3	LOAD.L	(A6)+OHAZA+0,D3	LOAD.L	(A6)+OHAZA+4,D4	LOAD.W	D3,#10-120$:	CALL	HAZARD		; tire qq nombres	DECJ.W,NMO D3,20$	POPM.L	D3,D4	RET;---------\\; RZHAZARD >;=========/; Remet  zro le gnrateur alatoire exclusif.; in	D3.W	+/- borne infrieure (min);	D4.W	+/- borne suprieure (max+1);	A4.L	^table d'exclusion; out	-; mod	D7.WRZHAZARD:	PUSHM.L	D4,A4	SUB.W	D4,D3	ADD.W	D4,#8-1	SR.W	D4,#340$:	CLR.B	(A4+)		; recommence le tirage exclusif	DEC.W	D4	JUMP,NE 40$	POPM.L	D4,A4	RET;---------\\; EXHAZARD >;=========/; Tire un nombre alatoire exclusif.; in	D3.W	+/- borne infrieure (min);	D4.W	+/- borne suprieure (max+1);	A4.L	^table d'exclusion; out	D4.W	+/- nombre alatoire: D3 <= n < D4; mod	D4.L, D7.WEXHAZARD:	PUSHM.L	D0..D3,A3	LOAD.W	D2,D410$:	LOAD.W	D1,D2	SUB.W	D1,D3	MUL.WU	D1,#20		; D1 <-- nb max d'essais20$:	LOAD.W	D4,D2		; D4 <-- borne suprieure	CALL	MMHAZARD	; D4 <-- nombre alatoire	LOAD.W	D0,D4	SUB.W	D0,D3	SR.W	D0,#3	TSET.B	(A4)+(D0.W):D4	; nombre dj sorti ?	JUMP',BC 80$		; non => 80$				; oui =>	DEC.W	D1		; encore un essai ?	JUMP,NE 20$		; oui => 20$	LOAD.W	D1,D2	SUB.W	D1,D3	LOAD.W	D4,D340$:	LOAD.W	D0,D4	SUB.W	D0,D3	SR.W	D0,#3	TSET.B	(A4)+(D0.W):D4	; nombre dj sorti ?	JUMP',BC 80$		; non => 80$	INC.W	D4	DEC.W	D1	JUMP,NE 40$	LOAD.L	A3,A4	LOAD.W	D1,D2	SUB.W	D1,D3	ADD.W	D1,#8-1	SR.W	D1,#350$:	CLR.B	(A3+)		; recommence le tirage exclusif	DEC.W	D1	JUMP,NE 50$	JUMP	10$80$:	POPM.L	D0..D3,A3	RET;---------\\; MMHAZARD >;=========/; Tire un nombre alatoire (16 bits) compris entre deux bornes.; in	D3.W	+/- borne infrieure (min);	D4.W	+/- borne suprieure (max+1); out	D4.W	+/- nombre alatoire: D3 <= n < D4; mod	D4.L, D7.WMMHAZARD:	PUSH.W	D2	LOAD.W	D2,D4	SUB.W	D2,D3		; D2 <-- sup - inf	CALL	HAZARD	AND.L	D4,#H'FFFF	DIV.WU	D4,D2	SWAP.W	D4		; D4 <-- reste de la division	ADD.W	D4,D3	POP.W	D2	RET;--------\\; HAZARD  >;========/; Tire un nombre alatoire de 32 bits.; On utilise un registre  dcalage de 63 bits, avec un XNOR entre; les bits 0 et 60 pour calculer le nouveau bit inject.; in	-; out	D4.L	nombre; mod	D4.LHAZARD:	PUSHM.L	D2,D3	LOAD.W	D2,#32-1	LOAD.L	D3,(A6)+OHAZA+0	LOAD.L	D4,(A6)+OHAZA+410$:	TEST.L	D4:#1	JUMP',BC 20$	TEST.L	D3:#30	JUMP',BC 35$	JUMP'	30$20$:	TEST.L	D3:#30	JUMP',BS 35$30$:	CLRX	RRX.L	D3,#1	RRX.L	D4,#1	JUMP'	40$35$:	SETX	RRX.L	D3,#1	RRX.L	D4,#140$:	LOAD.L	(A6)+OHAZA+0,D3	LOAD.L	(A6)+OHAZA+4,D4	DECJ.W,NMO D2,10$	POPM.L	D2,D3	RET; Routines graphiques; -------------------;---------\\; DRRASTER >;=========/; Dplace une surface rectangulaire mmoire/cran --> mmoire/cran.; in	D3.L	coordonne source (y;x);	A3.L	^mmoire source/^nil si cran;	D5.W	Iy source (si mmoire);	----;	D4.L	coordonne destination (y;x);	A4.L	^mmoire destination/^nil si cran;	D6.W	Iy destination (si mmoire);	----;	D1.L	hauteur/largeur (y;x);	D2.W	opration (INVDOT, SETDOT, CLRDOT ou LOADDOT); out	-; mod	D7.WDRRASTER:	PUSHM.L	D0..D6,A1,A2	TEST.W	D1		; dx <= 0 ?	JUMP,LE EXIT$	SWAP.W	D1	TEST.W	D1		; dy <= 0 ?	JUMP,LE EXIT$	SWAP.W	D1	EX.L	D1,D2		; D2/D1 <-- mode/dimensions	LOAD.L	A2,A0		; A2 <-- ^descripteur de la fentre	TEST.W	D4		; dpasse  gauche ?	JUMP',NC NoLeft$	ADD.W	D2,D4	JUMP,LE EXIT$	SUB.W	D3,D4	CLR.W	D4NoLeft$:	LOAD.W	D0,D4	ADD.W	D0,D2	SUB.W	D0,#LXWDO	; dpasse  droite ?	JUMP',LS NoRight$	SUB.W	D2,D0	JUMP,LE EXIT$NoRight$:	SWAP.W	D2	SWAP.W	D3	SWAP.W	D4	TEST.W	D4		; dpasse en haut ?	JUMP',NC NoUp$	ADD.W	D2,D4	JUMP,LE EXIT$	SUB.W	D3,D4	CLR.W	D4NoUp$:	LOAD.W	D0,D4	ADD.W	D0,D2	SUB.W	D0,#LYWDO	; dpasse en bas ?	JUMP',LS NoDown$	SUB.W	D2,D0	JUMP,LE EXIT$NoDown$:	SWAP.W	D2	SWAP.W	D3	SWAP.W	D4	TEST.B	(A0)+ODFCMD	; cran couleur ?	JUMP',NE COLOR$		; oui => COLOR$	LOAD.L	A1,(A6)+OADRASTER	CALL	(A1)		; appel de GRA_RASTER	JUMP'	EXIT$COLOR$:	CLR.W	D0	LOAD.B	D0,(A0)+ODFCNP	; D0 <-- nb de bits/pixel	TEST.L	D1:#BSRCCOUL	JUMP',BC CSRC$	MUL.WU	D5,D0		; D5 <-- Iy couleurCSRC$:	TEST.L	D1:#BDSTCOUL	JUMP',BC CDST$	MUL.WU	D6,D0		; D6 <-- Iy couleurCDST$:	LOAD.L	A1,(A6)+OADCRASTER	CALL	(A1)		; appel de GRA_CRASTEREXIT$:	POPM.L	D0..D6,A1,A2	RET;--------\\; DRMDEF  >;========/; Dfini la demi-trame super-rapidement.; in	D4.L	demi-trame; out	-; mod	D7.WDRMDEF:	LOAD.L (A0)+ODFTRA+0,D4	LOAD.L (A0)+ODFTRA+4,D4	RET;----------\\; OPEDISMAT >;==========/; Modifie le descripteur de la fentre pour pouvoir dessiner; directement dans une image.; in	A4.L	^image o dessiner; out	-; mod	D7.WOPEDISMAT:	PUSH.L	D4	LOAD.L	(A6)+OSDDIS+ODFABS,(A0)+ODFABS	LOAD.W	(A6)+OSDDIS+ODFIIX,(A0)+ODFIIX	LOAD.W	(A6)+OSDDIS+ODFIIY,(A0)+ODFIIY	LOAD.L	(A6)+OSDDIS+ODFY,(A0)+ODFY	LOAD.L	(A6)+OSDDIS+ODFDY,(A0)+ODFDY	LOAD.L	(A6)+OSDDIS+ODFFY,(A0)+ODFFY	LOAD.L	(A6)+OSDDIS+ODFFDY,(A0)+ODFFDY	LOAD.L	(A6)+OSDDIS+ODFWBY,(A0)+ODFWBY	LOAD.L	(A6)+OSDDIS+ODFWEY,(A0)+ODFWEY;;?	LOAD.W	(A6)+OSDDIS+ODFTTC,(A0)+ODFTTC	LOAD.B	(A6)+OSDDIS+ODFCMD,(A0)+ODFCMD	LOAD.L	(A0)+ODFABS,A4	LOAD.L	D4,#H'10000*LYWDO+LXWDO	CLR.L	(A0)+ODFY	LOAD.L	(A0)+ODFDY,D4	CLR.L	(A0)+ODFFY	LOAD.L	(A0)+ODFFDY,D4	CLR.L	(A0)+ODFWBY	LOAD.L	(A0)+ODFWEY,D4	LOAD.W	(A0)+ODFIIX,#1	LOAD.W	(A0)+ODFIIY,#LXWDO/8	TEST.B	(A0)+ODFCMD	JUMP',EQ EXIT$	CLR.W	D4	LOAD.B	D4,(A0)+ODFCNP	MUL.WU	D4,#LXWDO/8	LOAD.W	(A0)+ODFIIY,D4	LOAD.B	(A0)+ODFCMD,#2	; dessine en couleurEXIT$:	POP.L	D4	RET;----------\\; CLODISMAT >;==========/; Modifie le descripteur de la fentre pour pouvoir de nouveau; dessiner dans l'cran.; in	-; out	-; mod	D7.WCLODISMAT:	LOAD.L	(A0)+ODFABS,(A6)+OSDDIS+ODFABS	LOAD.W	(A0)+ODFIIX,(A6)+OSDDIS+ODFIIX	LOAD.W	(A0)+ODFIIY,(A6)+OSDDIS+ODFIIY	LOAD.L	(A0)+ODFY,(A6)+OSDDIS+ODFY	LOAD.L	(A0)+ODFDY,(A6)+OSDDIS+ODFDY	LOAD.L	(A0)+ODFFY,(A6)+OSDDIS+ODFFY	LOAD.L	(A0)+ODFFDY,(A6)+OSDDIS+ODFFDY	LOAD.L	(A0)+ODFWBY,(A6)+OSDDIS+ODFWBY	LOAD.L	(A0)+ODFWEY,(A6)+OSDDIS+ODFWEY;;?	LOAD.W	(A0)+ODFTTC,(A6)+OSDDIS+ODFTTC	LOAD.B	(A0)+ODFCMD,(A6)+OSDDIS+ODFCMD	RET; Gestion de la souris; --------------------;--------\\; IFMOUSE >;========/; Donne la position de la souris dans la swdo.; in	-; out	D4.L	position de la souris (y;x);	D7.W	erreur; mod	D4.L, D7.WIFMOUSE:	PUSH.L	D3	LIB	?IFMOUSE	JUMP',NE EXIT$	SUB.W	D4,(A0)+ODFFX	JUMP',HS OKX$	CLR.W	D4	LOAD.W	D7,#ERDIOUTOKX$:	SWAP.W	D4	SUB.W	D4,(A0)+ODFFY	JUMP',HS OKY$	CLR.W	D4	LOAD.W	D7,#ERDIOUTOKY$:	SWAP.W	D4EXIT$:	POP.L	D3	TEST.W	D7		; retour EQ/NE	RET;--------\\; PMOUSE  >;========/; Positionne la souris en (y;x).; in	D4.L	nouvelle position y;x; out	-; mod	D7.WPMOUSE:	LIB	?PMOUSE		; positionne la souris	RET;--------\\; CCMO    >;========/; Enlve la souris.; in	-; out	-; mod	D7.WCCMO:	PUSH.W	D3	TEST.B	(A6)+OCCMO	JUMP',T EXIT$	LOAD.B	D3,#AFCCMO	LIB	?AFCAR	SET.B	(A6)+OCCMOEXIT$:	POP.W	D3	RET;--------\\; SCMO    >;========/; Remet la souris.; in	-; out	-; mod	D7.WSCMO:	PUSH.W	D3	TEST.B	(A6)+OCCMO	JUMP',F EXIT$	LOAD.B	D3,#AFSCMO	LIB	?AFCAR	CLR.B	(A6)+OCCMOEXIT$:	POP.W	D3	RET;----------\\; WAITMOUSE >;==========/; Met la souris en attente (sablier).; in	-; out	-; mod	-WAITMOUSE:	PUSHM.L	D4,D7	CLR.W	D4	LIB	?WAITMOUSE	POPM.L	D4,D7	RET;----------\\; NORMMOUSE >;==========/; Remet la flche de la souris.; in	-; out	-; mod	-NORMMOUSE:	PUSHM.L	D4,D7	LOAD.W	D4,#1	LIB	?WAITMOUSE	POPM.L	D4,D7	RET;--------\\; CLRFIFO >;========/; Vide le fifo du clavier.; in	-; out	-; mod	D7.WCLRFIFO:	PUSH.L	D3LOOP$:	LIB	?IFCAR	JUMP,EQ LOOP$	POP.L	D3	RET;--------\\; AFMENU  >;========/; Affiche les soft-keys.; in	-; out	-; mod	D7.WAFMENU:	PUSH.L	A3	LOAD.L	A3,#R16"TXMENU$	LIB	?AFMENU	POP.L	A3	RETTXMENU$:	.ASCIZ	"Fin"	.ASCIZ	""		;     ;     ;     ;	.ASCIZ	"Prend       Sauve"	.ASCIZ	""		;     ;     ;     ;	.ASCIZ	" Df.            "	.ASCIZ	""		;     ;     ;     ;	.ASCIZ	""	.ASCIZ	""		;     ;     ;     ;	.ASCIZ	""	.ASCIZ	""		;     ;     ;     ;	.ASCIZ	"      Efface     "	.ASCIZ	""		;     ;     ;     ;	.EVEN	.END